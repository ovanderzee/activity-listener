{"version":3,"file":"activityListener.js","sources":["../src/activityListener.js","../src/index.js"],"sourcesContent":["const activityListener = (function () {\n    // internal state; isRunning - Boolean\n    let isRunning = true\n    // lookup table, callback is key, procdeure is value; callbackMap - WeakMap\n    const callbackMap = new Map()\n\n    /**\n     * Execute callback with checks\n     * @private\n     */\n    const execute = function (event, callback) {\n        if (!isRunning) {\n            return\n        }\n        try {\n            callback(event)\n        } catch (error) {\n            console.error('activityListener caught faulty callback')\n        }\n    }\n\n    /**\n     * Add or remove EventListeners\n     * @private\n     * @param {String} aim - 'add' | 'remove'\n     * @param {String} type - eventType\n     * @param {Function} callback - external function to call in case of event\n     */\n    const eventHandling = function (aim, type, callback) {\n        const eventOptions = { passive: true, capture: true }\n        const handler = `on${type}`\n        const procedure = callbackMap.get(callback).procedure\n        if (handler in window) {\n            window[aim + 'EventListener'](type, procedure, eventOptions)\n        } else if (handler in document) {\n            document[aim + 'EventListener'](type, procedure, eventOptions)\n        } else if (aim === 'add') {\n            console.warn(`activityListener rejected ${type}-event`)\n        }\n    }\n\n    /**\n     * Attach callback to event.\n     * @param {String} type - event type to watch\n     * @param {Function} callback\n     */\n    const register = function (type, callback) {\n        const procedure = function (event) {\n            execute(event, callback)\n        }\n        callbackMap.set(callback, { type: type, procedure: procedure })\n        eventHandling('add', type, callback)\n    }\n\n    /**\n     * Detach event/callback pair.\n     * @param {String} type - event type to watch\n     * @param {Function} callback\n     */\n    const erase = function (type, callback) {\n        eventHandling('remove', type, callback)\n        callbackMap.delete(callback)\n    }\n\n    /**\n     * Erase all callbacks, without knowing them :-)\n     */\n    const destroy = function () {\n        for (let [key, value] of callbackMap) {\n            erase(value.type, key)\n        }\n    }\n\n    /**\n     * Expose callbacks\n     */\n    const resume = function () {\n        isRunning = true\n    }\n\n    /**\n     * Block callbacks\n     */\n    const pause = function () {\n        isRunning = false\n    }\n\n    return {\n        clear: destroy, // deprecated\n        destroy: destroy,\n        erase: erase,\n        pause: pause,\n        register: register,\n        resume: resume,\n    }\n})()\n\nexport { activityListener }\n","import { activityListener } from './activityListener'\n\nconst index = activityListener\n\nexport default index\n"],"names":["index","isRunning","callbackMap","Map","eventHandling","aim","type","callback","eventOptions","passive","capture","handler","procedure","get","window","document","console","warn","erase","delete","destroy","key","value","clear","pause","register","set","event","error","execute","resume"],"mappings":"AAAA,MCEMA,EDFmB,WAErB,IAAIC,GAAY,EAEhB,MAAMC,EAAc,IAAIC,IAwBlBC,EAAgB,SAAUC,EAAKC,EAAMC,GACvC,MAAMC,EAAe,CAAEC,SAAS,EAAMC,SAAS,GACzCC,EAAU,KAAKL,IACfM,EAAYV,EAAYW,IAAIN,GAAUK,UACxCD,KAAWG,OACXA,OAAOT,EAAM,iBAAiBC,EAAMM,EAAWJ,GACxCG,KAAWI,SAClBA,SAASV,EAAM,iBAAiBC,EAAMM,EAAWJ,GAClC,QAARH,GACPW,QAAQC,KAAK,6BAA6BX,YAsB5CY,EAAQ,SAAUZ,EAAMC,GAC1BH,EAAc,SAAUE,EAAMC,GAC9BL,EAAYiB,OAAOZ,IAMjBa,EAAU,WACZ,IAAK,IAAKC,EAAKC,KAAUpB,EACrBgB,EAAMI,EAAMhB,KAAMe,IAkB1B,MAAO,CACHE,MAAOH,EACPA,QAASA,EACTF,MAAOA,EACPM,MARU,WACVvB,GAAY,GAQZwB,SA9Ca,SAAUnB,EAAMC,GAI7BL,EAAYwB,IAAInB,EAAU,CAAED,KAAMA,EAAMM,UAHtB,SAAUe,IArChB,SAAUA,EAAOpB,GAC7B,GAAKN,EAGL,IACIM,EAASoB,GACX,MAAOC,GACLZ,QAAQY,MAAM,4CA+BdC,CAAQF,EAAOpB,MAGnBH,EAAc,MAAOE,EAAMC,IA0C3BuB,OAjBW,WACX7B,GAAY,IA7EK"}