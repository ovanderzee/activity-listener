{"version":3,"file":"activityListener.js","sources":["../src/activityListener.js"],"sourcesContent":["const activityListener = (function () {\n    // internal state; isRunning - Boolean\n    let isRunning = true\n    // lookup table, callback is key, procdeure is value; callbackMap - WeakMap\n    let callbackMap = new WeakMap()\n\n    /**\n     * Execute callback with checks\n     * @private\n     */\n    const execute = function (event, callback) {\n        if (!isRunning || !callbackMap.get(callback)) {\n            return\n        }\n        try {\n            callback(event)\n        } catch (error) {\n            console.error('activityListener caught faulty callback')\n        }\n    }\n\n    /**\n     * Add or remove EventListeners\n     * @private\n     * @param {String} aim - 'add' | 'remove'\n     * @param {String} type - eventType\n     * @param {Function} callback - external function to call in case of event\n     */\n    const eventHandling = function (aim, type, callback) {\n        const eventOptions = { passive: true, capture: true }\n        const handler = `on${type}`\n        const procedure = callbackMap.get(callback)\n        if (handler in window) {\n            window[aim + 'EventListener'](type, procedure, eventOptions)\n        } else if (handler in document) {\n            document[aim + 'EventListener'](type, procedure, eventOptions)\n        } else if (aim === 'add') {\n            console.warn(`activityListener rejected ${type}-event`)\n        }\n    }\n\n    /**\n     * Attach callback to event.\n     * @param {String} type - event type to watch\n     * @param {Function} callback\n     */\n    const register = function (type, callback) {\n        const procedure = function (event) {\n            execute(event, callback)\n        }\n        callbackMap.set(callback, procedure)\n        eventHandling('add', type, callback)\n    }\n\n    /**\n     * Detach event/callback pair.\n     * @param {String} type - event type to watch\n     * @param {Function} callback\n     */\n    const erase = function (type, callback) {\n        eventHandling('remove', type, callbackMap.get(callback))\n        callbackMap.delete(callback)\n    }\n\n    /**\n     * Erase all callbacks, without knowing them :-)\n     */\n    const clear = function () {\n        callbackMap = new WeakMap()\n    }\n\n    /**\n     * Expose callbacks\n     */\n    const resume = function () {\n        isRunning = true\n    }\n\n    /**\n     * Block callbacks\n     */\n    const pause = function () {\n        isRunning = false\n    }\n\n    return {\n        clear: clear,\n        erase: erase,\n        pause: pause,\n        register: register,\n        resume: resume,\n    }\n})()\n\nexport { activityListener }\n"],"names":["isRunning","callbackMap","WeakMap","eventHandling","aim","type","callback","eventOptions","passive","capture","handler","procedure","get","window","document","console","warn","clear","erase","delete","pause","register","set","event","error","execute","resume"],"mappings":"wPAAyB,WAErB,IAAIA,GAAY,EAEZC,EAAc,IAAIC,QAMtB,MAkBMC,EAAgB,SAAUC,EAAKC,EAAMC,GACvC,MAAMC,EAAe,CAAEC,SAAS,EAAMC,SAAS,GACzCC,EAAU,KAAKL,IACfM,EAAYV,EAAYW,IAAIN,GAC9BI,KAAWG,OACXA,OAAOT,EAAM,iBAAiBC,EAAMM,EAAWJ,GACxCG,KAAWI,SAClBA,SAASV,EAAM,iBAAiBC,EAAMM,EAAWJ,GAClC,QAARH,GACPW,QAAQC,KAAK,6BAA6BX,YAgDlD,MAAO,CACHY,MAnBU,WACVhB,EAAc,IAAIC,SAmBlBgB,MA5BU,SAAUb,EAAMC,GAC1BH,EAAc,SAAUE,EAAMJ,EAAYW,IAAIN,IAC9CL,EAAYkB,OAAOb,IA2BnBc,MAPU,WACVpB,GAAY,GAOZqB,SA3Ca,SAAUhB,EAAMC,GAI7BL,EAAYqB,IAAIhB,GAHE,SAAUiB,IArChB,SAAUA,EAAOjB,GAC7B,GAAKN,GAAcC,EAAYW,IAAIN,GAGnC,IACIA,EAASiB,GACX,MAAOC,GACLT,QAAQS,MAAM,4CA+BdC,CAAQF,EAAOjB,MAGnBH,EAAc,MAAOE,EAAMC,IAuC3BoB,OAhBW,WACX1B,GAAY,IA3EK"}